--- PyQwt-4.1/sip/qwtcurve.sip.upgrade	2005-01-05 06:47:04.092132329 +0100
+++ PyQwt-4.1/sip/qwtcurve.sip	2005-01-05 06:50:29.518209734 +0100
@@ -83,6 +83,8 @@
     double x(int) const;
     double y(int) const;
     
+    virtual QwtDoubleRect boundingRect() const;
+
     double minXValue() const;
     double maxXValue() const;
     double minYValue() const;
--- PyQwt-4.1/pyqt_distutils/configure.py.upgrade	2005-01-05 06:47:03.948161009 +0100
+++ PyQwt-4.1/pyqt_distutils/configure.py	2005-01-05 06:50:29.516210132 +0100
@@ -72,7 +72,7 @@
 
 class ConfigError(Exception):
     """
-    Failed to import sipconfig of pyqtconfig
+    Failed to import sipconfig and/or pyqtconfig
 
     You must install sip and PyQt with 'configure.py' instead of 'build.py'
     """
--- PyQwt-4.1/setup.py.upgrade	2005-01-05 06:47:03.259298237 +0100
+++ PyQwt-4.1/setup.py	2005-01-05 06:52:03.735691319 +0100
@@ -24,7 +24,7 @@
 name = 'PyQwt'
 qwtdir = 'qwt-sources'
 snapshot = '%04d%02d%02d' % (time.localtime()[:3])
-version = '4.1'
+version = '4.1a'
 
 #
 # SIP VERSION
@@ -145,6 +145,9 @@
         'CurveDemo3.py',
         'DataDemo.py',
         'DialDemo.py',
+        'ErrorBarDemo.py',
+        'EventFilterDemo.py',
+        'Grab.py',
         'MapDemo.py',
         'MinPackDemo.py',
         'MultiDemo.py',
--- PyQwt-4.1/examples/QwtImagePlotDemo.py.upgrade	2003-08-03 20:08:32.000000000 +0200
+++ PyQwt-4.1/examples/QwtImagePlotDemo.py	2005-01-05 06:50:29.515210331 +0100
@@ -19,17 +19,25 @@
     bytedata = ((data*1.0-cmin)*scale + 0.4999).astype(UInt8)
     return bytedata + asarray(low).astype(UInt8)
 
+# bytescale()
+
 def linearX(nx, ny):
     return repeat(arange(nx, typecode = Float32)[:, NewAxis], ny, -1)
 
+# linearX()
+
 def linearY(nx, ny):
     return repeat(arange(ny, typecode = Float32)[NewAxis, :], nx, 0)
 
+# linearY()
+
 def square(n, min, max):
     x = arrayfns.span(min, max, n, n)
     y = transpose(x)
     return sin(x)*cos(y)
 
+# square()
+
 def rectangle(nx, ny, scale):
     # swap axes in the fromfunction call
     s = scale/(nx+ny)
@@ -42,6 +50,8 @@
     result = fromfunction(test, (ny, nx))
     return result
 
+# rectangle()
+
 
 class QwtPlotImage(QwtPlotMappedItem):
 
@@ -60,11 +70,13 @@
             self.plot.setAxisScale(QwtPlot.xBottom, *xScale)
         else:
             self.xMap = QwtDiMap(0, shape[0], 0, shape[0])
+            self.plot.setAxisScale(QwtPlot.xBottom, 0, shape[0])
         if yScale:
             self.yMap = QwtDiMap(0, shape[1], yScale[0], yScale[1])
             self.plot.setAxisScale(QwtPlot.yLeft, *yScale)
         else:
             self.yMap = QwtDiMap(0, shape[1], 0, shape[1])
+            self.plot.setAxisScale(QwtPlot.yLeft, 0, shape[1])
         self.image = toQImage(bytescale(self.xyzs)).mirror(0, 1)
         for i in range(0, 256):
             self.image.setColor(i, qRgb(i, 0, 255-i))
@@ -78,6 +90,7 @@
         and copy the visible region to scale it to the canvas.
         """
         # calculate y1, y2
+        # the scanline order (index y) is inverted with respect to the y-axis
         y1 = y2 = self.image.height()
         y1 *= (self.yMap.d2() - yMap.d2())
         y1 /= (self.yMap.d2() - self.yMap.d1())
@@ -85,12 +98,12 @@
         y2 *= (self.yMap.d2() - yMap.d1())
         y2 /= (self.yMap.d2() - self.yMap.d1())
         y2 = min(self.image.height(), int(y2+0.5))
-        # calculate x1, x1
+        # calculate x1, x2 -- the pixel order (index x) is normal
         x1 = x2 = self.image.width()
-        x1 *= (self.xMap.d2() - xMap.d2())
+        x1 *= (xMap.d1() - self.xMap.d1())
         x1 /= (self.xMap.d2() - self.xMap.d1())
         x1 = max(0, int(x1-0.5))
-        x2 *= (self.xMap.d2() - xMap.d1())
+        x2 *= (xMap.d2() - self.xMap.d1())
         x2 /= (self.xMap.d2() - self.xMap.d1())
         x2 = min(self.image.width(), int(x2+0.5))
         # copy
@@ -102,8 +115,9 @@
 
     # drawImage()
 
-# QwtPlotImage()
+# class QwtPlotImage
     
+
 class QwtImagePlot(QwtPlot):
 
     def __init__(self, *args):
@@ -157,17 +171,19 @@
         
         # replot
         self.replot()
-	
+
+    # __init__()
+
     def drawCanvasItems(self, painter, rectangle, maps, filter):
         self.plotImage.drawImage(
             painter, maps[QwtPlot.xBottom], maps[QwtPlot.yLeft])
         QwtPlot.drawCanvasItems(self, painter, rectangle, maps, filter)
 
+    # drawCanvasItems()
 
     def onMouseMoved(self, e):
         pass
 
-
     # onMouseMoved()
 
     def onMousePressed(self, e):
@@ -229,18 +245,24 @@
 
     # toggleCurve()
 
+# class QwtImagePlot
+
+
 def make():
     demo = QwtImagePlot()
     demo.resize(500, 300)
     demo.show()
     return demo
 
+# make()
+
 def main(args):
     app = QApplication(args)
     demo = make()
     app.setMainWidget(demo)
     app.exec_loop()
 
+# main()
 
 # Admire
 if __name__ == '__main__':
--- PyQwt-4.1/examples/Grab.py.upgrade	2003-11-02 17:24:39.000000000 +0100
+++ PyQwt-4.1/examples/Grab.py	2005-01-05 06:50:29.512210929 +0100
@@ -23,6 +23,7 @@
     'CurveDemo3',
     'DataDemo',
     'DialDemo',
+    'ErrorBarDemo',
     'EventFilterDemo',
     'MapDemo',
     'MultiDemo',
--- PyQwt-4.1/examples/ErrorBarDemo.py.upgrade	2005-01-05 06:50:29.511211128 +0100
+++ PyQwt-4.1/examples/ErrorBarDemo.py	2005-01-05 07:10:28.061672833 +0100
@@ -0,0 +1,313 @@
+#!/usr/bin/env python
+
+import sys
+from qt import *
+from qwt import *
+
+# try to import scipy, Numeric, or numarray
+try:
+    from scipy import *
+except ImportError:
+    try:
+        from Numeric import *
+    except ImportError:
+        try:
+            from numarray import *
+        except ImportError:
+            raise ImportError, 'Failed to import scipy, Numeric, or numarray'
+
+
+class ErrorBarPlotCurve(QwtPlotCurve):
+
+    def __init__(self, parent,
+                 x = [], y = [], dx = None, dy = None,
+                 curvePen = QPen(Qt.NoPen),
+                 curveStyle = QwtCurve.Lines,
+                 curveSymbol = QwtSymbol(),
+                 errorPen = QPen(Qt.NoPen),
+                 errorCap = 0,
+                 errorOnTop = False,
+                 ):
+        """A curve of x versus y data with error bars in dx and dy.
+
+        Horizontal error bars are plotted if dx is not None.
+        Vertical error bars are plotted if dy is not None.
+
+        x and y must be sequences with a shape (N,) and dx and dy must be
+        sequences (if not None) with a shape (), (N,), or (2, N):
+        - if dx or dy has a shape () or (N,), the error bars are given by
+          (x-dx, x+dx) or (y-dy, y+dy),
+        - if dx or dy has a shape (2, N), the error bars are given by
+          (x-dx[0], x+dx[1]) or (y-dy[0], y+dy[1]).
+
+        curvePen is the pen used to plot the curve
+        
+        curveStyle is the style used to plot the curve
+        
+        curveSymbol is the symbol used to plot the symbols
+        
+        errorPen is the pen used to plot the error bars
+        
+        errorCap is the size of the error bar caps
+        
+        errorOnTop is a boolean:
+        - if True, plot the error bars on top of the curve,
+        - if False, plot the curve on top of the error bars.
+        """
+
+        QwtPlotCurve.__init__(self, parent)
+        self.setData(x, y, dx, dy)
+        self.setPen(curvePen)
+        self.setStyle(curveStyle)
+        self.setSymbol(curveSymbol)
+        self.errorPen = errorPen
+        self.errorCap = errorCap
+        self.errorOnTop = errorOnTop
+
+    # __init__()
+
+    def setData(self, x, y, dx = None, dy = None):
+        """Set x versus y data with error bars in dx and dy.
+
+        Horizontal error bars are plotted if dx is not None.
+        Vertical error bars are plotted if dy is not None.
+
+        x and y must be sequences with a shape (N,) and dx and dy must be
+        sequences (if not None) with a shape (), (N,), or (2, N):
+        - if dx or dy has a shape () or (N,), the error bars are given by
+          (x-dx, x+dx) or (y-dy, y+dy),
+        - if dx or dy has a shape (2, N), the error bars are given by
+          (x-dx[0], x+dx[1]) or (y-dy[0], y+dy[1]).
+        """
+        
+        self.__x = asarray(x, Float)
+        if len(self.__x.shape) != 1:
+            raise RuntimeError, 'len(asarray(x).shape) != 1'
+
+        self.__y = asarray(y, Float)
+        if len(self.__y.shape) != 1:
+            raise RuntimeError, 'len(asarray(y).shape) != 1'
+        if len(self.__x) != len(self.__y):
+            raise RuntimeError, 'len(asarray(x)) != len(asarray(y))' 
+
+        if dx is None:
+            self.__dx = None
+        else:
+            self.__dx = asarray(dx, Float)
+        if len(self.__dx.shape) not in [0, 1, 2]:
+            raise RuntimeError, 'len(asarray(dx).shape) not in [0, 1, 2]'
+            
+        if dy is None:
+            self.__dy = dy
+        else:
+            self.__dy = asarray(dy, Float)
+        if len(self.__dy.shape) not in [0, 1, 2]:
+            raise RuntimeError, 'len(asarray(dy).shape) not in [1, 2]'
+        
+        QwtPlotCurve.setData(self, self.__x, self.__y)
+
+    # setData()
+        
+    def boundingRect(self):
+        """Return the bounding rectangle of the data, error bars included.
+        """
+        if self.__dx is None:
+            xmin = min(self.__x)
+            xmax = max(self.__x)
+        elif len(self.__dx.shape) in [0, 1]:
+            xmin = min(self.__x - self.__dx)
+            xmax = max(self.__x + self.__dx)
+        else:
+            xmin = min(self.__x - self.__dx[0])
+            xmax = max(self.__x + self.__dx[1])
+
+        if self.__dy is None:
+            ymin = min(self.__y)
+            ymax = max(self.__y)
+        elif len(self.__dy.shape) in [0, 1]:
+            ymin = min(self.__y - self.__dy)
+            ymax = max(self.__y + self.__dy)
+        else:
+            ymin = min(self.__y - self.__dy[0])
+            ymax = max(self.__y + self.__dy[1])
+
+        return QwtDoubleRect(xmin, xmax, ymin, ymax)
+        
+    # boundingRect()
+
+    def draw(self, painter, xMap, yMap, first, last = -1):
+        """Draw an interval of the curve, including the error bars
+
+        painter is the QPainter used to draw the curve
+
+        xMap is the QwtDiMap used to map x-values to pixels
+
+        yMap is the QwtDiMap used to map y-values to pixels
+        
+        first is the index of the first data point to draw
+
+        last is the index of the last data point to draw. If last < 0, last
+        is transformed to index the last data point
+        """
+        
+        if last < 0:
+            last = self.dataSize() - 1
+        if not self.verifyRange(first, last):
+            return
+
+        if self.errorOnTop:
+            QwtPlotCurve.draw(self, painter, xMap, yMap, first, last)
+
+        # draw the error bars
+        painter.save()
+        painter.setPen(self.errorPen)
+
+        # draw the error bars with caps in the x direction
+        if self.__dx is not None:
+            # draw the bars
+            if len(self.__dx.shape) in [0, 1]:
+                xmin = (self.__x - self.__dx)[first:last+1]
+                xmax = (self.__x + self.__dx)[first:last+1]
+            else:
+                xmin = (self.__x - self.__dx[0])[first:last+1]
+                xmax = (self.__x + self.__dx[1])[first:last+1]
+            y = self.__y[first:last+1]
+            n, i, j = len(y), 0, 0
+            lines = QPointArray(2*n)
+            while i < n:
+                yi = yMap.transform(y[i])
+                lines.setPoint(j, xMap.transform(xmin[i]), yi)
+                j += 1
+                lines.setPoint(j, xMap.transform(xmax[i]), yi)
+                j += 1; i += 1
+            painter.drawLineSegments(lines)
+            if self.errorCap > 0:
+                # draw the caps
+                cap = self.errorCap/2
+                n, i, j = len(y), 0, 0
+                lines = QPointArray(4*n)
+                while i < n:
+                    yi = yMap.transform(y[i])
+                    lines.setPoint(j, xMap.transform(xmin[i]), yi - cap)
+                    j += 1
+                    lines.setPoint(j, xMap.transform(xmin[i]), yi + cap)
+                    j += 1
+                    lines.setPoint(j, xMap.transform(xmax[i]), yi - cap)
+                    j += 1
+                    lines.setPoint(j, xMap.transform(xmax[i]), yi + cap)
+                    j += 1; i += 1
+            painter.drawLineSegments(lines)
+
+        # draw the error bars with caps in the y direction
+        if self.__dy is not None:
+            # draw the bars
+            if len(self.__dy.shape) in [0, 1]:
+                ymin = (self.__y - self.__dy)[first:last+1]
+                ymax = (self.__y + self.__dy)[first:last+1]
+            else:
+                ymin = (self.__y - self.__dy[0])[first:last+1]
+                ymax = (self.__y + self.__dy[1])[first:last+1]
+            x = self.__x[first:last+1]
+            n, i, j = len(x), 0, 0
+            lines = QPointArray(2*n)
+            while i < n:
+                xi = xMap.transform(x[i])
+                lines.setPoint(j, xi, yMap.transform(ymin[i]))
+                j += 1
+                lines.setPoint(j, xi, yMap.transform(ymax[i]))
+                j += 1; i += 1
+            painter.drawLineSegments(lines)
+            # draw the caps
+            if self.errorCap > 0:
+                cap = self.errorCap/2
+                n, i, j = len(x), 0, 0
+                lines = QPointArray(4*n)
+                while i < n:
+                    xi = xMap.transform(x[i])
+                    lines.setPoint(j, xi - cap, yMap.transform(ymin[i]))
+                    j += 1
+                    lines.setPoint(j, xi + cap, yMap.transform(ymin[i]))
+                    j += 1
+                    lines.setPoint(j, xi - cap, yMap.transform(ymax[i]))
+                    j += 1
+                    lines.setPoint(j, xi + cap, yMap.transform(ymax[i]))
+                    j += 1; i += 1
+            painter.drawLineSegments(lines)
+
+        painter.restore()
+
+        if not self.errorOnTop:
+            QwtPlotCurve.draw(self, painter, xMap, yMap, first, last)
+
+    # draw()
+
+# class ErrorBarPlotCurve
+
+
+def make():
+    # create a plot with a white canvas
+    demo = QwtPlot("Errorbar Demonstation")
+    demo.setCanvasBackground(Qt.white)
+    # calculate data and errors for a curve with error bars
+    x = arange(0, 10.1, 0.5, Float)
+    y = sin(x)
+    dy = 0.2 * abs(y)
+    # dy = (0.15 * abs(y), 0.25 * abs(y)) # uncomment for asymmetric error bars
+    dx = 0.2 # all error bars the same size
+    errorOnTop = False # uncomment to draw the curve on top of the error bars
+    # errorOnTop = True # uncomment to draw the error bars on top of the curve
+    curve = ErrorBarPlotCurve(
+        demo,
+        x = x,
+        y = y,
+        dx = dx,
+        dy = dy,
+        curvePen = QPen(Qt.black, 2),
+        curveStyle = QwtCurve.Spline,
+        curveSymbol = QwtSymbol(QwtSymbol.Ellipse,
+                                QBrush(Qt.red),
+                                QPen(Qt.black, 2),
+                                QSize(9, 9)),
+        errorPen = QPen(Qt.blue, 2),
+        errorCap = 10,
+        errorOnTop = errorOnTop,
+        )
+    demo.insertCurve(curve)
+    demo.resize(600, 400)
+    demo.replot()
+    demo.show()
+    return demo
+
+# make()
+
+
+def main(args):
+    app = QApplication(args)
+    demo = make()
+    app.setMainWidget(demo)
+    zoomer = QwtPlotZoomer(QwtPlot.xBottom,
+                           QwtPlot.yLeft,
+                           QwtPicker.DragSelection,
+                           QwtPicker.AlwaysOff,
+                           demo.canvas())
+    zoomer.setRubberBandPen(QPen(Qt.green))
+    picker = QwtPlotPicker(QwtPlot.xBottom,
+                           QwtPlot.yLeft,
+                           QwtPicker.NoSelection,
+                           QwtPlotPicker.CrossRubberBand,
+                           QwtPicker.AlwaysOn,
+                           demo.canvas())
+    picker.setRubberBandPen(QPen(Qt.green))
+    picker.setCursorLabelPen(QPen(Qt.black))
+    app.exec_loop()
+
+# main()
+
+
+# Admire!
+if __name__ == '__main__':
+    main(sys.argv)
+
+# Local Variables: ***
+# mode: python ***
+# End: ***
--- PyQwt-4.1/THANKS.upgrade	2005-01-05 06:47:03.045340859 +0100
+++ PyQwt-4.1/THANKS	2005-01-05 06:50:29.505212323 +0100
@@ -33,3 +33,6 @@
 
 Ulrich Berning
 - for an initial version of configure.py
+
+Tony Willis
+- for fixing QwtPlotImageDemo.py
